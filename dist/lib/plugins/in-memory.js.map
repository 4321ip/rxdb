{"version":3,"sources":["../../../src/plugins/in-memory.ts"],"names":["prepareInMemoryRxCollection","instance","memoryStorage","createStorageInstance","databaseName","collectionName","schema","jsonSchema","options","pouchSettings","multiInstance","storageInstance","pouch","internals","inMemory","INIT_DONE","PouchDB","adapters","memory","collectionCacheMap","has","collectionPromiseCacheMap","get","then","col","InMemoryRxCollection","preparePromise","prepareChild","set","WeakMap","BULK_DOC_OPTIONS","new_edits","BULK_DOC_OPTIONS_FALSE","parentCollection","database","name","toCleanSchema","_methods","_eventCounter","_isInMemory","onDestroy","destroy","_crypter","password","_changeStreams","forEach","stream","cancel","Object","entries","statics","funName","fun","defineProperty","bind","_observable$","Subject","_changeEventBuffer","parentProto","getPrototypeOf","_oldPouchPut","_pouchPut","_nonPersistentRevisions","Set","_nonPersistentRevisionsSubject","setIndexes","_subs","push","subscribe","cE","doc","_docCache","documentId","_handleChangeEvent","replicateExistingDocuments","thisToParentSub","streamChangedDocuments","pipe","applyChangedDocumentToPouch","changeRev","next","size","parentToThisSub","awaitPersistence","PROMISE_RESOLVE_VOID","obj","overwrite","ret","add","rev","$emit","changeEvent","hasChangeWithRevision","_rev","compact","syncCouchDB","RxCollectionBase","rxSchema","newSchemaJson","keyCompression","properties","_attachments","removeEncryption","complete","encrypted","values","filter","val","fromCollection","toCollection","allDocs","attachments","include_docs","allRows","docs","rows","map","row","language","primaryKey","primaryPath","length","Promise","resolve","bulkDocs","all","indexes","indexAr","indexName","join","createIndex","ddoc","index","fields","rxCollection","prevFilter","_i","_doNotEmitSet","observable","changes","since","live","changeAr","change","emitFlag","id","d","docData","transformedDoc","_id","oldDoc","bulkRet","ok","Error","JSON","stringify","setTimeout","rxdb","prototypes","RxCollection","proto","RxDBInMemoryPlugin"],"mappings":"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","sourcesContent":["/**\n * This plugin adds RxCollection.inMemory()\n * Which replicates the collection into an in-memory-collection\n * So you can do faster queries and also query over encrypted fields.\n * Writes will still run on the original collection\n */\n\nimport {\n    Subject,\n    fromEvent as ObservableFromEvent,\n    Observable,\n    firstValueFrom\n} from 'rxjs';\n\nimport {\n    filter,\n    map,\n    mergeMap,\n    delay\n} from 'rxjs/operators';\n\nimport type {\n    RxCollection,\n    RxCouchDBReplicationState,\n    PouchDBInstance,\n    RxPlugin,\n    PouchBulkDocResultRow,\n    RxChangeEvent\n} from '../types';\nimport {\n    RxCollectionBase\n} from '../rx-collection';\nimport {\n    clone,\n    PROMISE_RESOLVE_VOID,\n    randomCouchString\n} from '../util';\nimport {\n    PouchDB,\n    getRxStoragePouch,\n    pouchSwapIdToPrimary,\n    pouchSwapPrimaryToId,\n} from '../plugins/pouchdb';\nimport {\n    createCrypter\n} from '../crypter';\nimport {\n    createChangeEventBuffer\n} from '../change-event-buffer';\nimport {\n    createRxSchema,\n    RxSchema\n} from '../rx-schema';\nimport {\n    newRxError\n} from '../rx-error';\nimport { getDocumentDataOfRxChangeEvent } from '../rx-change-event';\nimport { _handleFromStorageInstance, _handleToStorageInstance } from '../rx-collection-helper';\n\nconst collectionCacheMap = new WeakMap();\nconst collectionPromiseCacheMap = new WeakMap();\nconst BULK_DOC_OPTIONS = {\n    new_edits: true\n};\nconst BULK_DOC_OPTIONS_FALSE = {\n    new_edits: false\n};\n\nexport\n    class InMemoryRxCollection<RxDocumentType, OrmMethods>\n    extends RxCollectionBase<RxDocumentType, OrmMethods> {\n\n    constructor(\n        public readonly parentCollection: RxCollection<RxDocumentType, OrmMethods>,\n        public readonly pouchSettings?: any\n    ) {\n        super(\n            parentCollection.database as any,\n            parentCollection.name,\n            toCleanSchema(parentCollection.schema),\n            pouchSettings, // pouchSettings\n            {} as any,\n            (parentCollection as any)._methods);\n        this._isInMemory = true;\n\n        parentCollection.onDestroy.then(() => this.destroy());\n        this._crypter = createCrypter(this.database.password, this.schema);\n        this._changeStreams = [];\n\n        /**\n         * runs on parentCollection.destroy()\n         * Cleans up everything to free up memory\n         */\n        this.onDestroy.then(() => {\n            this._changeStreams.forEach((stream: any) => stream.cancel());\n            // delete all data\n            this.storageInstance.internals.pouch.destroy();\n        });\n\n        // add orm functions and options from parent\n        this.options = parentCollection.options;\n        Object\n            .entries(parentCollection.statics)\n            .forEach(([funName, fun]) => {\n                Object.defineProperty(this, funName, {\n                    get: () => (fun as any).bind(this)\n                });\n            });\n\n        this._observable$ = new Subject();\n        this._changeEventBuffer = createChangeEventBuffer(this as any);\n\n        const parentProto = Object.getPrototypeOf(parentCollection);\n        this._oldPouchPut = (parentProto as any)._pouchPut.bind(this);\n\n        this._nonPersistentRevisions = new Set();\n        this._nonPersistentRevisionsSubject = new Subject(); // emits Set.size() when Set is changed\n    }\n    public _changeStreams: any;\n    public _oldPouchPut: Function;\n    public _nonPersistentRevisions: any;\n    public _nonPersistentRevisionsSubject: any;\n\n\n    /**\n     * @overwrite\n     */\n    public _eventCounter: number = 0;\n\n    prepareChild() {\n        return setIndexes(this.schema, this.storageInstance.internals.pouch)\n            .then(() => {\n                this._subs.push(\n                    (this._observable$ as any).subscribe((cE: RxChangeEvent) => {\n                        // when data changes, send it to RxDocument in docCache\n                        const doc = this._docCache.get(cE.documentId);\n                        if (doc) doc._handleChangeEvent(cE);\n                    })\n                );\n            })\n            // initial sync parent's docs to own\n            .then(() => replicateExistingDocuments(this.parentCollection as any, this as any))\n            .then(() => {\n                /**\n                 * create an ongoing replications between both sides\n                 */\n                const thisToParentSub = streamChangedDocuments(this as any)\n                    .pipe(\n                        mergeMap(doc => applyChangedDocumentToPouch(this.parentCollection, doc)\n                            .then(() => doc['_rev'])\n                        )\n                    )\n                    .subscribe(changeRev => {\n                        this._nonPersistentRevisions.delete(changeRev);\n                        this._nonPersistentRevisionsSubject.next(this._nonPersistentRevisions.size);\n                    });\n                this._subs.push(thisToParentSub);\n\n                const parentToThisSub = streamChangedDocuments(this.parentCollection)\n                    .subscribe(doc => applyChangedDocumentToPouch(this as any, doc));\n                this._subs.push(parentToThisSub);\n            });\n    }\n\n    /**\n     * waits until all writes are persistent\n     * in the parent collection\n     */\n    awaitPersistence(): Promise<any> {\n        if (this._nonPersistentRevisions.size === 0) {\n            return PROMISE_RESOLVE_VOID;\n        }\n        return firstValueFrom(\n            this._nonPersistentRevisionsSubject.pipe(\n                filter(() => this._nonPersistentRevisions.size === 0),\n            )\n        );\n    }\n\n    /**\n     * To know which events are replicated and which are not,\n     * the _pouchPut is wrapped\n     * @overwrite\n     */\n    _pouchPut(obj: any, overwrite: boolean) {\n        return this._oldPouchPut(obj, overwrite).then((ret: any) => {\n            this._nonPersistentRevisions.add(ret.rev);\n            return ret;\n        });\n    }\n    $emit(changeEvent: RxChangeEvent) {\n        const doc = getDocumentDataOfRxChangeEvent(changeEvent);\n        if ((this._changeEventBuffer as any).hasChangeWithRevision(doc && doc._rev)) {\n            return;\n        }\n\n        (this._observable$ as any).next(changeEvent);\n\n        // run compaction each 10 events\n        this._eventCounter++;\n        if (this._eventCounter === 10) {\n            this._eventCounter = 0;\n            this.storageInstance.internals.pouch.compact();\n        }\n    }\n\n    /**\n     * @overwrite\n     * Replication on the inMemory is dangerous,\n     * replicate with it's parent instead\n     */\n    syncCouchDB(): RxCouchDBReplicationState {\n        throw newRxError('IM2');\n    }\n}\n\n/**\n * returns a version of the schema that:\n * - disabled the keyCompression\n * - has no encryption\n * - has no attachments\n */\nfunction toCleanSchema(rxSchema: RxSchema): RxSchema {\n    const newSchemaJson = clone(rxSchema.jsonSchema);\n    newSchemaJson.keyCompression = false;\n    delete newSchemaJson.properties._rev;\n    delete newSchemaJson.properties._attachments;\n\n    const removeEncryption = (schema: any, complete: any) => {\n        delete schema.encrypted;\n        Object.values(schema)\n            .filter(val => typeof val === 'object')\n            .forEach(val => removeEncryption(val, complete));\n    };\n    removeEncryption(newSchemaJson, newSchemaJson);\n\n    return createRxSchema(newSchemaJson);\n}\n\n/**\n * replicates all documents from the parent to the inMemoryCollection\n * @return Promise that resolves with an array of the docs data\n */\nexport function replicateExistingDocuments(\n    fromCollection: RxCollection,\n    toCollection: RxCollection\n): Promise<any[]> {\n    const pouch: PouchDBInstance = fromCollection.storageInstance.internals.pouch;\n    return pouch.allDocs({\n        attachments: false,\n        include_docs: true\n    }).then(allRows => {\n        const docs = allRows\n            .rows\n            .map((row: any) => row.doc)\n            .filter((doc: any) => !doc.language) // do not replicate design-docs\n            .map((doc: any) => _handleFromStorageInstance(fromCollection, doc))\n            // swap back primary because keyCompression:false\n            .map((doc: any) => {\n                const primaryKey: string = fromCollection.schema.primaryPath as any;\n                return pouchSwapPrimaryToId(primaryKey, doc);\n            });\n\n        if (docs.length === 0) {\n            // nothing to replicate\n            return Promise.resolve([]);\n        }\n        else {\n            return toCollection.storageInstance.internals.pouch.bulkDocs({\n                docs\n            }, BULK_DOC_OPTIONS_FALSE)\n                .then(() => docs);\n        }\n    });\n}\n\n/**\n * sets the indexes from the schema at the pouchdb\n */\nexport function setIndexes(\n    schema: RxSchema,\n    pouch: PouchDBInstance,\n): Promise<any> {\n    return Promise.all(\n        schema.indexes\n            .map(indexAr => {\n                const indexName = 'idx-rxdb-' + indexAr.join(',');\n                return pouch.createIndex({\n                    ddoc: indexName,\n                    name: indexName,\n                    index: {\n                        fields: indexAr\n                    }\n                });\n            })\n    );\n}\n\n/**\n * returns an observable that streams all changes\n * as plain documents that have no encryption or keyCompression.\n * We use this to replicate changes from one collection to the other\n * @param prevFilter can be used to filter changes before doing anything\n * @return observable that emits document-data\n */\nexport function streamChangedDocuments(\n    rxCollection: RxCollection<any, any>,\n    prevFilter = (_i: any) => true\n): Observable<any> {\n    if (!(rxCollection as any)._doNotEmitSet) {\n        (rxCollection as any)._doNotEmitSet = new Set();\n    }\n\n    const observable = ObservableFromEvent(\n        rxCollection.storageInstance.internals.pouch\n            .changes({\n                since: 'now',\n                live: true,\n                include_docs: true\n            }),\n        'change'\n    )\n        .pipe(\n            /**\n             * we need this delay because with pouchdb 7.2.2\n             * it happened that _doNotEmitSet.add() from applyChangedDocumentToPouch()\n             * was called after the change was streamed downwards\n             * which then leads to a wrong detection\n             */\n            delay(0),\n            map((changeAr: any) => changeAr[0]), // rxjs emits an array for whatever reason\n            filter(change => {\n                // changes on the doNotEmit-list shell not be fired\n                const emitFlag = change.id + ':' + change.doc._rev;\n                if ((rxCollection as any)._doNotEmitSet.has(emitFlag)) {\n                    return false;\n                } else {\n                    return true;\n                }\n            }),\n            filter(change => prevFilter(change)),\n            map(change => _handleFromStorageInstance(rxCollection, change.doc)),\n            map(d => {\n                const primaryKey: string = rxCollection.schema.primaryPath as any;\n                return pouchSwapIdToPrimary(primaryKey, d);\n            })\n        );\n    return observable;\n}\n\n/**\n * writes the doc-data into the pouchdb of the collection\n * without changeing the revision\n */\nexport function applyChangedDocumentToPouch(\n    rxCollection: RxCollection<any, any>,\n    docData: any\n): Promise<any> {\n    if (!(rxCollection as any)._doNotEmitSet) {\n        (rxCollection as any)._doNotEmitSet = new Set();\n    }\n\n    const primaryKey: string = rxCollection.schema.primaryPath as any;\n\n    let transformedDoc = _handleToStorageInstance(rxCollection, docData);\n    transformedDoc = pouchSwapPrimaryToId(\n        primaryKey,\n        transformedDoc\n    );\n\n    return rxCollection.storageInstance.internals.pouch.get(transformedDoc._id)\n        .then((oldDoc: any) => transformedDoc._rev = oldDoc._rev)\n        .catch(() => {\n            // doc not found, do not use a revision\n            delete transformedDoc._rev;\n        }).then(() => rxCollection.storageInstance.internals.pouch.bulkDocs({\n            docs: [transformedDoc]\n        }, BULK_DOC_OPTIONS))\n        .then((bulkRet: any) => {\n            if (bulkRet.length > 0 && !(bulkRet[0] as PouchBulkDocResultRow).ok) {\n                throw new Error(JSON.stringify(bulkRet[0]));\n            }\n            // set the flag so this does not appear in the own event-stream again\n            const emitFlag = transformedDoc._id + ':' + (bulkRet[0] as PouchBulkDocResultRow).rev;\n            (rxCollection as any)._doNotEmitSet.add(emitFlag);\n\n            // remove from the list later to not have a memory-leak\n            setTimeout(() => (rxCollection as any)._doNotEmitSet.delete(emitFlag), 30 * 1000);\n\n            return transformedDoc;\n        });\n}\n\nlet INIT_DONE = false;\n/**\n * called in the proto of RxCollection\n */\nexport async function inMemory(\n    this: RxCollection\n): Promise<RxCollection> {\n    if (!INIT_DONE) {\n        INIT_DONE = true;\n        // ensure memory-adapter is added\n        if (!(PouchDB as any).adapters || !(PouchDB as any).adapters.memory) {\n            throw newRxError('IM1');\n        }\n    }\n\n    if (collectionCacheMap.has(this)) {\n        // already exists for this collection -> wait until synced\n        return collectionPromiseCacheMap.get(this)\n            .then(() => collectionCacheMap.get(this));\n    }\n\n    const col = new InMemoryRxCollection(this);\n    await prepareInMemoryRxCollection(col);\n\n    const preparePromise = col.prepareChild();\n    collectionCacheMap.set(this, col);\n    collectionPromiseCacheMap.set(this, preparePromise);\n\n    return preparePromise.then(() => col) as any;\n}\n\nexport async function prepareInMemoryRxCollection(instance: InMemoryRxCollection<any, {}>): Promise<void> {\n    const memoryStorage = getRxStoragePouch('memory', {});\n    instance.storageInstance = await memoryStorage.createStorageInstance({\n        databaseName: 'rxdb-in-memory',\n        collectionName: randomCouchString(10),\n        schema: instance.schema.jsonSchema,\n        options: instance.pouchSettings,\n        multiInstance: false\n    });\n    (instance as any).pouch = instance.storageInstance.internals.pouch;\n}\n\n\nexport const rxdb = true;\nexport const prototypes = {\n    RxCollection: (proto: any) => {\n        proto.inMemory = inMemory;\n    }\n};\n\nexport const RxDBInMemoryPlugin: RxPlugin = {\n    name: 'in-memory',\n    rxdb,\n    prototypes\n};\n"],"file":"in-memory.js"}