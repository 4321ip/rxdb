{"version":3,"sources":["../../../src/plugins/attachments.ts"],"names":["ensureSchemaSupportsAttachments","doc","schemaJson","collection","schema","jsonSchema","attachments","link","getAttachmentDataMeta","storageStatics","data","hash","length","blobBufferUtil","size","digest","hashKey","postMigrateDocument","_action","preMigrateDocument","docData","_attachments","mustDecrypt","shouldEncrypt","oldCollection","newAttachments","Promise","all","Object","keys","map","attachmentId","attachment","docPrimary","primaryPath","storageInstance","getAttachmentData","rawAttachmentData","database","storage","statics","meta","type","toString","then","dataString","createBlobBuffer","_crypter","_decryptString","putAttachment","_atomicQueue","docWriteData","_data","id","writeRow","previous","document","writeResult","attachmentData","fromStorageInstanceResult","newData","_rev","_dataSync$","next","skipIfSame","currentMeta","newHash","newDigest","getAttachment","encrypted","_encryptString","_assignMethodsToAttachment","entries","forEach","funName","fun","defineProperty","get","bind","RxAttachment","remove","getData","primary","plainData","ret","getStringData","bufferBlob","rxDocument","getValue","allAttachments","rxdb","prototypes","RxDocument","proto","allAttachments$","pipe","attachmentsData","overwritable","hooks","RxDBAttachmentsPlugin","name"],"mappings":"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","sourcesContent":["import {\n    map\n} from 'rxjs/operators';\nimport {\n    blobBufferUtil,\n    flatClone\n} from './../util';\nimport {\n    newRxError\n} from '../rx-error';\nimport type {\n    RxDocument,\n    RxPlugin,\n    BlobBuffer,\n    OldRxCollection,\n    RxDocumentWriteData,\n    RxAttachmentData,\n    RxDocumentData,\n    RxAttachmentCreator,\n    RxAttachmentWriteData,\n    RxStorageStatics,\n    RxAttachmentDataMeta\n} from '../types';\nimport type { RxSchema } from '../rx-schema';\nimport { writeSingle } from '../rx-storage-helper';\nimport { _handleToStorageInstance } from '../rx-collection-helper';\n\nfunction ensureSchemaSupportsAttachments(doc: any) {\n    const schemaJson = doc.collection.schema.jsonSchema;\n    if (!schemaJson.attachments) {\n        throw newRxError('AT1', {\n            link: 'https://pubkey.github.io/rxdb/rx-attachment.html'\n        });\n    }\n}\n\nconst _assignMethodsToAttachment = function (attachment: any) {\n    Object\n        .entries(attachment.doc.collection.attachments)\n        .forEach(([funName, fun]) => {\n            Object.defineProperty(attachment, funName, {\n                get: () => (fun as any).bind(attachment)\n            });\n        });\n};\n\n/**\n * an RxAttachment is basically just the attachment-stub\n * wrapped so that you can access the attachment-data\n */\nexport class RxAttachment {\n    public doc: RxDocument;\n    public id: string;\n    public type: string;\n    public length: number;\n    public digest: string;\n    constructor({\n        doc,\n        id,\n        type,\n        length,\n        digest\n    }: any) {\n        this.doc = doc;\n        this.id = id;\n        this.type = type;\n        this.length = length;\n        this.digest = digest;\n\n        _assignMethodsToAttachment(this);\n    }\n\n    async remove(): Promise<void> {\n        this.doc._atomicQueue = this.doc._atomicQueue\n            .then(async () => {\n                const docWriteData: RxDocumentWriteData<{}> = flatClone(this.doc._data);\n                docWriteData._attachments = flatClone(docWriteData._attachments);\n                delete docWriteData._attachments[this.id];\n\n                const writeResult: RxDocumentData<any> = await writeSingle(\n                    this.doc.collection.storageInstance,\n                    {\n                        previous: _handleToStorageInstance(this.doc.collection, flatClone(this.doc._data)),\n                        document: _handleToStorageInstance(this.doc.collection, docWriteData)\n                    }\n                );\n\n                const newData = flatClone(this.doc._data);\n                newData._rev = writeResult._rev;\n                newData._attachments = writeResult._attachments;\n                this.doc._dataSync$.next(newData);\n\n            });\n        return this.doc._atomicQueue;\n    }\n\n    /**\n     * returns the data for the attachment\n     */\n    async getData(): Promise<BlobBuffer> {\n        const plainData = await this.doc.collection.storageInstance.getAttachmentData(\n            this.doc.primary,\n            this.id\n        );\n        if (shouldEncrypt(this.doc.collection.schema)) {\n            const dataString = await blobBufferUtil.toString(plainData);\n            const ret = blobBufferUtil.createBlobBuffer(\n                this.doc.collection._crypter._decryptString(dataString),\n                this.type as any\n            );\n            return ret;\n        } else {\n            return plainData;\n        }\n    }\n\n    getStringData(): Promise<string> {\n        return this.getData().then(bufferBlob => blobBufferUtil.toString(bufferBlob));\n    }\n}\n\nexport function fromStorageInstanceResult(\n    id: string,\n    attachmentData: RxAttachmentData,\n    rxDocument: RxDocument\n) {\n    return new RxAttachment({\n        doc: rxDocument,\n        id,\n        type: attachmentData.type,\n        length: attachmentData.length,\n        digest: attachmentData.digest\n    });\n}\n\nfunction shouldEncrypt(schema: RxSchema): boolean {\n    return !!(schema.jsonSchema.attachments && schema.jsonSchema.attachments.encrypted);\n}\n\nexport async function putAttachment(\n    this: RxDocument,\n    {\n        id,\n        data,\n        type = 'text/plain'\n    }: RxAttachmentCreator,\n    /**\n     * If set to true, the write will be skipped\n     * when the attachment already contains the same data.\n     */\n    skipIfSame: boolean = true\n): Promise<RxAttachment> {\n    ensureSchemaSupportsAttachments(this);\n\n    /**\n     * Then encryption plugin is only able to encrypt strings,\n     * so unpack as string first.\n     */\n\n    if (shouldEncrypt(this.collection.schema)) {\n        const dataString = await blobBufferUtil.toString(data);\n        const encrypted = this.collection._crypter._encryptString(dataString);\n        data = blobBufferUtil.createBlobBuffer(encrypted, 'text/plain');\n    }\n\n    const statics = this.collection.database.storage.statics;\n    this._atomicQueue = this._atomicQueue\n        .then(async () => {\n            if (skipIfSame && this._data._attachments && this._data._attachments[id]) {\n                const currentMeta = this._data._attachments[id];\n                const newHash = await statics.hash(data);\n                const newDigest = statics.hashKey + '-' + newHash;\n                if (currentMeta.type === type && currentMeta.digest === newDigest) {\n                    // skip because same data and same type\n                    return this.getAttachment(id);\n                }\n            }\n\n            const docWriteData: RxDocumentWriteData<{}> = flatClone(this._data);\n            docWriteData._attachments = flatClone(docWriteData._attachments);\n\n            const meta = await getAttachmentDataMeta(\n                this.collection.database.storage.statics,\n                data\n            );\n            docWriteData._attachments[id] = {\n                digest: meta.digest,\n                length: meta.length,\n                type,\n                data: data\n            };\n\n            const writeRow = {\n                previous: _handleToStorageInstance(this.collection, flatClone(this._data)),\n                document: _handleToStorageInstance(this.collection, flatClone(docWriteData))\n            };\n\n            const writeResult = await writeSingle(\n                this.collection.storageInstance,\n                writeRow\n            );\n\n            const attachmentData = writeResult._attachments[id];\n            const attachment = fromStorageInstanceResult(\n                id,\n                attachmentData,\n                this\n            );\n\n            const newData = flatClone(this._data);\n            newData._rev = writeResult._rev;\n            newData._attachments = writeResult._attachments;\n            this._dataSync$.next(newData);\n\n            return attachment;\n        });\n    return this._atomicQueue;\n}\n\n/**\n * get an attachment of the document by its id\n */\nexport function getAttachment(\n    this: RxDocument,\n    id: string\n): RxAttachment | null {\n    ensureSchemaSupportsAttachments(this);\n    const docData: any = this._dataSync$.getValue();\n    if (!docData._attachments || !docData._attachments[id])\n        return null;\n\n    const attachmentData = docData._attachments[id];\n    const attachment = fromStorageInstanceResult(\n        id,\n        attachmentData,\n        this\n    );\n    return attachment;\n}\n\n/**\n * returns all attachments of the document\n */\nexport function allAttachments(\n    this: RxDocument\n): RxAttachment[] {\n    ensureSchemaSupportsAttachments(this);\n    const docData: any = this._dataSync$.getValue();\n\n    // if there are no attachments, the field is missing\n    if (!docData._attachments) {\n        return [];\n    }\n    return Object.keys(docData._attachments)\n        .map(id => {\n            return fromStorageInstanceResult(\n                id,\n                docData._attachments[id],\n                this\n            );\n        });\n}\n\nexport async function preMigrateDocument<RxDocType>(\n    data: {\n        docData: RxDocumentData<RxDocType>;\n        oldCollection: OldRxCollection\n    }\n): Promise<void> {\n    const attachments = data.docData._attachments;\n    if (attachments) {\n        const mustDecrypt = !!shouldEncrypt(data.oldCollection.schema);\n        const newAttachments: { [attachmentId: string]: RxAttachmentWriteData } = {};\n        await Promise.all(\n            Object.keys(attachments).map(async (attachmentId) => {\n                const attachment: RxAttachmentData = attachments[attachmentId];\n                const docPrimary: string = (data.docData as any)[data.oldCollection.schema.primaryPath];\n\n                let rawAttachmentData = await data.oldCollection.storageInstance.getAttachmentData(docPrimary, attachmentId);\n                if (mustDecrypt) {\n                    rawAttachmentData = await blobBufferUtil.toString(rawAttachmentData)\n                        .then(dataString => blobBufferUtil.createBlobBuffer(\n                            data.oldCollection._crypter._decryptString(dataString),\n                            (attachment as RxAttachmentData).type as any\n                        ));\n                }\n\n                const meta = await getAttachmentDataMeta(\n                    data.oldCollection.database.storage.statics,\n                    rawAttachmentData\n                );\n                newAttachments[attachmentId] = {\n                    digest: meta.digest,\n                    length: meta.length,\n                    type: attachment.type,\n                    data: rawAttachmentData\n                };\n            })\n        );\n\n        /**\n         * Hooks mutate the input\n         * instead of returning stuff\n         */\n        (data.docData as RxDocumentWriteData<RxDocType>)._attachments = newAttachments;\n    }\n}\n\nexport async function postMigrateDocument(_action: any): Promise<void> {\n    /**\n     * No longer needed because\n     * we store the attachemnts data buffers directly in the document.\n     */\n    return;\n}\n\nexport async function getAttachmentDataMeta(\n    storageStatics: RxStorageStatics,\n    data: BlobBuffer\n): Promise<RxAttachmentDataMeta> {\n    const hash = await storageStatics.hash(data);\n    const length = blobBufferUtil.size(data);\n    return {\n        digest: storageStatics.hashKey + '-' + hash,\n        length\n    }\n}\n\nexport const rxdb = true;\nexport const prototypes = {\n    RxDocument: (proto: any) => {\n        proto.putAttachment = putAttachment;\n        proto.getAttachment = getAttachment;\n        proto.allAttachments = allAttachments;\n        Object.defineProperty(proto, 'allAttachments$', {\n            get: function allAttachments$() {\n                return this._dataSync$\n                    .pipe(\n                        map((data: any) => {\n                            if (!data['_attachments']) {\n                                return {};\n                            }\n                            return data['_attachments'];\n                        }),\n                        map((attachmentsData: any) => Object.entries(\n                            attachmentsData\n                        )),\n                        map(entries => {\n                            return (entries as any)\n                                .map(([id, attachmentData]: any) => {\n                                    return fromStorageInstanceResult(\n                                        id,\n                                        attachmentData,\n                                        this\n                                    );\n                                });\n                        })\n                    );\n            }\n        });\n    }\n};\nexport const overwritable = {};\nexport const hooks = {\n    preMigrateDocument,\n    postMigrateDocument\n};\n\nexport const RxDBAttachmentsPlugin: RxPlugin = {\n    name: 'attachments',\n    rxdb,\n    prototypes,\n    overwritable,\n    hooks\n};\n"],"file":"attachments.js"}