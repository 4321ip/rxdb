{"version":3,"sources":["../../../src/plugins/encryption.ts"],"names":["AES","cryptoEnc","newRxTypeError","newRxError","hash","PROMISE_RESOLVE_FALSE","findLocalDocument","storePasswordHashIntoDatabase","rxDatabase","password","pwHash","pwHashDocumentId","localDocumentsStore","pwHashDoc","docData","_id","value","_attachments","bulkWrite","document","destroy","passwordHash","existingPasswordHash","minPassLength","encrypt","encrypted","toString","decrypt","cipherText","decrypted","_encryptString","_decryptString","encryptedValue","rxdb","prototypes","Crypter","proto","overwritable","validatePassword","length","RxDBEncryptionPlugin","name","hooks","createRxDatabase","db"],"mappings":"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","sourcesContent":["/**\n * this plugin adds the encryption-capabilities to rxdb\n * It's using crypto-js/aes for password-encryption\n * @link https://github.com/brix/crypto-js\n */\n\nimport AES from 'crypto-js/aes';\nimport * as cryptoEnc from 'crypto-js/enc-utf8';\n\nimport {\n    newRxTypeError,\n    newRxError\n} from '../rx-error';\n\nimport type {\n    Crypter\n} from '../crypter';\nimport type {\n    RxPlugin,\n    RxDatabase,\n    RxLocalDocumentData\n} from '../types';\nimport { hash, PROMISE_RESOLVE_FALSE } from '../util';\nimport { findLocalDocument } from '../rx-storage-helper';\n\nconst minPassLength = 8;\n\nexport function encrypt(value: string, password: any): string {\n    const encrypted = AES.encrypt(value, password);\n    return encrypted.toString();\n}\n\nexport function decrypt(cipherText: string, password: any): string {\n    const decrypted = AES.decrypt(cipherText, password);\n    return decrypted.toString(cryptoEnc);\n}\n\nconst _encryptString = function (this: Crypter, value: string) {\n    return encrypt(value, this.password);\n};\n\nconst _decryptString = function (this: Crypter, encryptedValue: string): string {\n    const decrypted = decrypt(encryptedValue, this.password);\n    return decrypted;\n};\n\n\nexport type PasswordHashDocument = RxLocalDocumentData<{\n    value: string;\n}>;\n\n/**\n * validates and inserts the password hash into the internal collection\n * to ensure there is/was no other instance with a different password\n * which would cause strange side effects when both instances save into the same db\n */\nexport async function storePasswordHashIntoDatabase(\n    rxDatabase: RxDatabase\n): Promise<boolean> {\n    if (!rxDatabase.password) {\n        return PROMISE_RESOLVE_FALSE;\n    }\n    const pwHash = hash(rxDatabase.password);\n    const pwHashDocumentId = 'pwHash';\n\n    const pwHashDoc = await findLocalDocument<PasswordHashDocument>(\n        rxDatabase.localDocumentsStore,\n        pwHashDocumentId\n    );\n    if (!pwHashDoc) {\n        const docData: PasswordHashDocument = {\n            _id: pwHashDocumentId,\n            value: pwHash,\n            _attachments: {}\n        };\n        await rxDatabase.localDocumentsStore.bulkWrite([{\n            document: docData\n        }]);\n        return true;\n    } else if (pwHash !== pwHashDoc.value) {\n        // different hash was already set by other instance\n        await rxDatabase.destroy();\n        throw newRxError('DB1', {\n            passwordHash: hash(rxDatabase.password),\n            existingPasswordHash: pwHashDoc.value\n        });\n    } else {\n        return true;\n    }\n}\n\n\n\n\nexport const rxdb = true;\nexport const prototypes = {\n    /**\n     * set crypto-functions for the Crypter.prototype\n     */\n    Crypter: (proto: any) => {\n        proto._encryptString = _encryptString;\n        proto._decryptString = _decryptString;\n    }\n};\nexport const overwritable = {\n    validatePassword: function (password: any) {\n        if (password && typeof password !== 'string') {\n            throw newRxTypeError('EN1', {\n                password\n            });\n        }\n        if (password && password.length < minPassLength) {\n            throw newRxError('EN2', {\n                minPassLength,\n                password\n            });\n        }\n    }\n};\n\nexport const RxDBEncryptionPlugin: RxPlugin = {\n    name: 'encryption',\n    rxdb,\n    prototypes,\n    overwritable,\n    hooks: {\n        createRxDatabase: (db: RxDatabase) => {\n            return storePasswordHashIntoDatabase(db);\n        }\n    }\n};\n"],"file":"encryption.js"}