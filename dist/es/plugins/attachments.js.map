{"version":3,"sources":["../../../src/plugins/attachments.ts"],"names":["map","blobBufferUtil","flatClone","newRxError","writeSingle","_handleToStorageInstance","ensureSchemaSupportsAttachments","doc","schemaJson","collection","schema","jsonSchema","attachments","link","getAttachmentDataMeta","storageStatics","data","hash","length","size","digest","hashKey","postMigrateDocument","_action","preMigrateDocument","docData","_attachments","mustDecrypt","shouldEncrypt","oldCollection","newAttachments","Promise","all","Object","keys","attachmentId","attachment","docPrimary","primaryPath","storageInstance","getAttachmentData","rawAttachmentData","database","storage","statics","meta","type","toString","then","dataString","createBlobBuffer","_crypter","_decryptString","putAttachment","_atomicQueue","docWriteData","_data","id","writeRow","previous","document","writeResult","attachmentData","fromStorageInstanceResult","newData","_rev","_dataSync$","next","skipIfSame","currentMeta","newHash","newDigest","getAttachment","encrypted","_encryptString","_assignMethodsToAttachment","entries","forEach","funName","fun","defineProperty","get","bind","RxAttachment","remove","getData","primary","plainData","ret","getStringData","bufferBlob","rxDocument","getValue","allAttachments","rxdb","prototypes","RxDocument","proto","allAttachments$","pipe","attachmentsData","overwritable","hooks","RxDBAttachmentsPlugin","name"],"mappings":"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","sourcesContent":["import {\n    map\n} from 'rxjs/operators';\nimport {\n    blobBufferUtil,\n    flatClone\n} from './../util';\nimport {\n    newRxError\n} from '../rx-error';\nimport type {\n    RxDocument,\n    RxPlugin,\n    BlobBuffer,\n    OldRxCollection,\n    RxDocumentWriteData,\n    RxAttachmentData,\n    RxDocumentData,\n    RxAttachmentCreator,\n    RxAttachmentWriteData,\n    RxStorageStatics,\n    RxAttachmentDataMeta\n} from '../types';\nimport type { RxSchema } from '../rx-schema';\nimport { writeSingle } from '../rx-storage-helper';\nimport { _handleToStorageInstance } from '../rx-collection-helper';\n\nfunction ensureSchemaSupportsAttachments(doc: any) {\n    const schemaJson = doc.collection.schema.jsonSchema;\n    if (!schemaJson.attachments) {\n        throw newRxError('AT1', {\n            link: 'https://pubkey.github.io/rxdb/rx-attachment.html'\n        });\n    }\n}\n\nconst _assignMethodsToAttachment = function (attachment: any) {\n    Object\n        .entries(attachment.doc.collection.attachments)\n        .forEach(([funName, fun]) => {\n            Object.defineProperty(attachment, funName, {\n                get: () => (fun as any).bind(attachment)\n            });\n        });\n};\n\n/**\n * an RxAttachment is basically just the attachment-stub\n * wrapped so that you can access the attachment-data\n */\nexport class RxAttachment {\n    public doc: RxDocument;\n    public id: string;\n    public type: string;\n    public length: number;\n    public digest: string;\n    constructor({\n        doc,\n        id,\n        type,\n        length,\n        digest\n    }: any) {\n        this.doc = doc;\n        this.id = id;\n        this.type = type;\n        this.length = length;\n        this.digest = digest;\n\n        _assignMethodsToAttachment(this);\n    }\n\n    async remove(): Promise<void> {\n        this.doc._atomicQueue = this.doc._atomicQueue\n            .then(async () => {\n                const docWriteData: RxDocumentWriteData<{}> = flatClone(this.doc._data);\n                docWriteData._attachments = flatClone(docWriteData._attachments);\n                delete docWriteData._attachments[this.id];\n\n                const writeResult: RxDocumentData<any> = await writeSingle(\n                    this.doc.collection.storageInstance,\n                    {\n                        previous: _handleToStorageInstance(this.doc.collection, flatClone(this.doc._data)),\n                        document: _handleToStorageInstance(this.doc.collection, docWriteData)\n                    }\n                );\n\n                const newData = flatClone(this.doc._data);\n                newData._rev = writeResult._rev;\n                newData._attachments = writeResult._attachments;\n                this.doc._dataSync$.next(newData);\n\n            });\n        return this.doc._atomicQueue;\n    }\n\n    /**\n     * returns the data for the attachment\n     */\n    async getData(): Promise<BlobBuffer> {\n        const plainData = await this.doc.collection.storageInstance.getAttachmentData(\n            this.doc.primary,\n            this.id\n        );\n        if (shouldEncrypt(this.doc.collection.schema)) {\n            const dataString = await blobBufferUtil.toString(plainData);\n            const ret = blobBufferUtil.createBlobBuffer(\n                this.doc.collection._crypter._decryptString(dataString),\n                this.type as any\n            );\n            return ret;\n        } else {\n            return plainData;\n        }\n    }\n\n    getStringData(): Promise<string> {\n        return this.getData().then(bufferBlob => blobBufferUtil.toString(bufferBlob));\n    }\n}\n\nexport function fromStorageInstanceResult(\n    id: string,\n    attachmentData: RxAttachmentData,\n    rxDocument: RxDocument\n) {\n    return new RxAttachment({\n        doc: rxDocument,\n        id,\n        type: attachmentData.type,\n        length: attachmentData.length,\n        digest: attachmentData.digest\n    });\n}\n\nfunction shouldEncrypt(schema: RxSchema): boolean {\n    return !!(schema.jsonSchema.attachments && schema.jsonSchema.attachments.encrypted);\n}\n\nexport async function putAttachment(\n    this: RxDocument,\n    {\n        id,\n        data,\n        type = 'text/plain'\n    }: RxAttachmentCreator,\n    /**\n     * If set to true, the write will be skipped\n     * when the attachment already contains the same data.\n     */\n    skipIfSame: boolean = true\n): Promise<RxAttachment> {\n    ensureSchemaSupportsAttachments(this);\n\n    /**\n     * Then encryption plugin is only able to encrypt strings,\n     * so unpack as string first.\n     */\n\n    if (shouldEncrypt(this.collection.schema)) {\n        const dataString = await blobBufferUtil.toString(data);\n        const encrypted = this.collection._crypter._encryptString(dataString);\n        data = blobBufferUtil.createBlobBuffer(encrypted, 'text/plain');\n    }\n\n    const statics = this.collection.database.storage.statics;\n    this._atomicQueue = this._atomicQueue\n        .then(async () => {\n            if (skipIfSame && this._data._attachments && this._data._attachments[id]) {\n                const currentMeta = this._data._attachments[id];\n                const newHash = await statics.hash(data);\n                const newDigest = statics.hashKey + '-' + newHash;\n                if (currentMeta.type === type && currentMeta.digest === newDigest) {\n                    // skip because same data and same type\n                    return this.getAttachment(id);\n                }\n            }\n\n            const docWriteData: RxDocumentWriteData<{}> = flatClone(this._data);\n            docWriteData._attachments = flatClone(docWriteData._attachments);\n\n            const meta = await getAttachmentDataMeta(\n                this.collection.database.storage.statics,\n                data\n            );\n            docWriteData._attachments[id] = {\n                digest: meta.digest,\n                length: meta.length,\n                type,\n                data: data\n            };\n\n            const writeRow = {\n                previous: _handleToStorageInstance(this.collection, flatClone(this._data)),\n                document: _handleToStorageInstance(this.collection, flatClone(docWriteData))\n            };\n\n            const writeResult = await writeSingle(\n                this.collection.storageInstance,\n                writeRow\n            );\n\n            const attachmentData = writeResult._attachments[id];\n            const attachment = fromStorageInstanceResult(\n                id,\n                attachmentData,\n                this\n            );\n\n            const newData = flatClone(this._data);\n            newData._rev = writeResult._rev;\n            newData._attachments = writeResult._attachments;\n            this._dataSync$.next(newData);\n\n            return attachment;\n        });\n    return this._atomicQueue;\n}\n\n/**\n * get an attachment of the document by its id\n */\nexport function getAttachment(\n    this: RxDocument,\n    id: string\n): RxAttachment | null {\n    ensureSchemaSupportsAttachments(this);\n    const docData: any = this._dataSync$.getValue();\n    if (!docData._attachments || !docData._attachments[id])\n        return null;\n\n    const attachmentData = docData._attachments[id];\n    const attachment = fromStorageInstanceResult(\n        id,\n        attachmentData,\n        this\n    );\n    return attachment;\n}\n\n/**\n * returns all attachments of the document\n */\nexport function allAttachments(\n    this: RxDocument\n): RxAttachment[] {\n    ensureSchemaSupportsAttachments(this);\n    const docData: any = this._dataSync$.getValue();\n\n    // if there are no attachments, the field is missing\n    if (!docData._attachments) {\n        return [];\n    }\n    return Object.keys(docData._attachments)\n        .map(id => {\n            return fromStorageInstanceResult(\n                id,\n                docData._attachments[id],\n                this\n            );\n        });\n}\n\nexport async function preMigrateDocument<RxDocType>(\n    data: {\n        docData: RxDocumentData<RxDocType>;\n        oldCollection: OldRxCollection\n    }\n): Promise<void> {\n    const attachments = data.docData._attachments;\n    if (attachments) {\n        const mustDecrypt = !!shouldEncrypt(data.oldCollection.schema);\n        const newAttachments: { [attachmentId: string]: RxAttachmentWriteData } = {};\n        await Promise.all(\n            Object.keys(attachments).map(async (attachmentId) => {\n                const attachment: RxAttachmentData = attachments[attachmentId];\n                const docPrimary: string = (data.docData as any)[data.oldCollection.schema.primaryPath];\n\n                let rawAttachmentData = await data.oldCollection.storageInstance.getAttachmentData(docPrimary, attachmentId);\n                if (mustDecrypt) {\n                    rawAttachmentData = await blobBufferUtil.toString(rawAttachmentData)\n                        .then(dataString => blobBufferUtil.createBlobBuffer(\n                            data.oldCollection._crypter._decryptString(dataString),\n                            (attachment as RxAttachmentData).type as any\n                        ));\n                }\n\n                const meta = await getAttachmentDataMeta(\n                    data.oldCollection.database.storage.statics,\n                    rawAttachmentData\n                );\n                newAttachments[attachmentId] = {\n                    digest: meta.digest,\n                    length: meta.length,\n                    type: attachment.type,\n                    data: rawAttachmentData\n                };\n            })\n        );\n\n        /**\n         * Hooks mutate the input\n         * instead of returning stuff\n         */\n        (data.docData as RxDocumentWriteData<RxDocType>)._attachments = newAttachments;\n    }\n}\n\nexport async function postMigrateDocument(_action: any): Promise<void> {\n    /**\n     * No longer needed because\n     * we store the attachemnts data buffers directly in the document.\n     */\n    return;\n}\n\nexport async function getAttachmentDataMeta(\n    storageStatics: RxStorageStatics,\n    data: BlobBuffer\n): Promise<RxAttachmentDataMeta> {\n    const hash = await storageStatics.hash(data);\n    const length = blobBufferUtil.size(data);\n    return {\n        digest: storageStatics.hashKey + '-' + hash,\n        length\n    }\n}\n\nexport const rxdb = true;\nexport const prototypes = {\n    RxDocument: (proto: any) => {\n        proto.putAttachment = putAttachment;\n        proto.getAttachment = getAttachment;\n        proto.allAttachments = allAttachments;\n        Object.defineProperty(proto, 'allAttachments$', {\n            get: function allAttachments$() {\n                return this._dataSync$\n                    .pipe(\n                        map((data: any) => {\n                            if (!data['_attachments']) {\n                                return {};\n                            }\n                            return data['_attachments'];\n                        }),\n                        map((attachmentsData: any) => Object.entries(\n                            attachmentsData\n                        )),\n                        map(entries => {\n                            return (entries as any)\n                                .map(([id, attachmentData]: any) => {\n                                    return fromStorageInstanceResult(\n                                        id,\n                                        attachmentData,\n                                        this\n                                    );\n                                });\n                        })\n                    );\n            }\n        });\n    }\n};\nexport const overwritable = {};\nexport const hooks = {\n    preMigrateDocument,\n    postMigrateDocument\n};\n\nexport const RxDBAttachmentsPlugin: RxPlugin = {\n    name: 'attachments',\n    rxdb,\n    prototypes,\n    overwritable,\n    hooks\n};\n"],"file":"attachments.js"}